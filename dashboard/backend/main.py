import requests
import os
import random
import string
from datetime import datetime, timedelta
from collections import defaultdict

from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from supabase import create_client, Client
from dotenv import load_dotenv

# --- SETUP & CONFIGURATION ---
load_dotenv()

app = FastAPI()

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount Static Files (Frontend)
app.mount("/static", StaticFiles(directory="static"), name="static")

# Supabase & API Keys
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_KEY")
supabase: Client = create_client(supabase_url, supabase_key)
WEATHER_API_KEY = os.getenv("WEATHER_API_KEY")

# --- DATA MODELS ---
class SensorData(BaseModel):
    mac_address: str
    temperature: float = None
    humidity: float = None
    soil_moisture: float = None
    ph_value: float = None
    rain_value: float = None
    electrical_conductivity: float = None
    nitrogen: float = None
    phosphorus: float = None
    potassium: float = None

class DeviceRegister(BaseModel):
    mac_address: str
    mac_key: str  # Generated by ESP32

class DeviceVerifyByKey(BaseModel):
    mac_key: str

# ==========================================
#      SECTION 1: HARDWARE & DEVICE API
# ==========================================

# --- 1. DEVICE SELF-REGISTRATION ---
# Called by ESP32 on boot to register itself or update its key
@app.post("/api/register-device")
async def register_device(data: DeviceRegister):
    try:
        # Check if device exists
        exists = supabase.table("device_registry").select("*").eq("mac_address", data.mac_address).execute()
        
        if not exists.data:
            # Register new device. Status 0 (Inactive) until User claims it.
            supabase.table("device_registry").insert({
                "mac_address": data.mac_address,
                "mac_key": data.mac_key,
                "status_indicator": 0 
            }).execute()
            
            print(f"ðŸ†• Device Registered: {data.mac_address} | Key: {data.mac_key}")
            return {"status": "registered"}
        else:
            # Update last_seen and Key (in case of reset)
            supabase.table("device_registry").update({
                "last_seen": "now()",
                "mac_key": data.mac_key 
            }).eq("mac_address", data.mac_address).execute()
            
            print(f"ðŸ”„ Device Reconnected: {data.mac_address}")
            return {"status": "existing"}

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- 2. VERIFY KEY (Frontend) ---
# Called by the Web App when user types in the Key to claim a device
@app.post("/api/verify-device-key")
async def verify_device_key(data: DeviceVerifyByKey):
    try:
        # A. Find Device by Key
        registry = supabase.table("device_registry").select("*").eq("mac_key", data.mac_key).execute()
        
        if not registry.data:
            return JSONResponse(status_code=404, content={"message": "Invalid Key. Device not found."})

        device_info = registry.data[0]
        mac_address = device_info['mac_address']

        # B. Check if already owned
        owner = supabase.table("profiles").select("*").eq("mac_address", mac_address).execute()
        if owner.data:
            return JSONResponse(status_code=409, content={"message": "Device already linked to another user."})

        # C. Activate Device (Set Status = 1)
        supabase.table("device_registry").update({"status_indicator": 1}).eq("mac_address", mac_address).execute()

        # D. Return MAC to Frontend (so Frontend can link it to the User Profile)
        return {
            "message": "Device verified & activated", 
            "status": "available", 
            "mac_address": mac_address 
        }

    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# --- 3. HARDWARE LOGGING ---
# Called by ESP32 to send sensor data
@app.post("/api/hardware-log")
async def log_hardware_data(data: SensorData):
    try:
        # 1. Check Status in Registry
        device_check = supabase.table("device_registry").select("status_indicator").eq("mac_address", data.mac_address).execute()
        
        if not device_check.data:
            return JSONResponse(status_code=404, content={"message": "Device not registered"})
            
        status = device_check.data[0]['status_indicator']
        
        # 2. STATUS CHECK: If 0, Reject Data (Save DB space)
        if status == 0:
            print(f"ðŸ’¤ Ignored Data from {data.mac_address} (Status: Inactive)")
            return JSONResponse(status_code=403, content={"message": "Device is inactive (Link it in Dashboard)"})

        # 3. Find Owner & Log Data
        owner = supabase.table("profiles").select("id").eq("mac_address", data.mac_address).execute()
        
        if not owner.data:
            print(f"âš ï¸ Device {data.mac_address} has no owner in Profiles table.")
            return JSONResponse(status_code=403, content={"message": "Unclaimed device"})
            
        user_id = owner.data[0]['id']
        
        payload = {
            "user_id": user_id,
            "mac_address": data.mac_address,
            "temperature": data.temperature,
            "humidity": data.humidity,
            "soil_moisture": data.soil_moisture,
            "ph_value": data.ph_value,
            "rain_value": data.rain_value,
            "electrical_conductivity": data.electrical_conductivity,
            "nitrogen": data.nitrogen,
            "phosphorus": data.phosphorus,
            "potassium": data.potassium
        }
        
        print(f"ðŸ“¦ Logging Data for User {user_id}: {payload}")
        
        supabase.table("sensor_data").insert(payload).execute()
        return {"message": "Logged"}

    except Exception as e:
        print(f"ðŸ”¥ LOG ERROR: {e}")
        return JSONResponse(status_code=500, content={"error": str(e)})


# ==========================================
#      SECTION 2: WEB FRONTEND ROUTES
# ==========================================

@app.get("/")
async def read_root(): return FileResponse('static/login.html')

@app.get("/signup")
async def read_signup(): return FileResponse('static/signup.html')

@app.get("/setup-hardware")
async def read_setup(): return FileResponse('static/setup_hardware.html')

@app.get("/dashboard")
async def read_dashboard(): return FileResponse('static/dashboard.html')

@app.get("/prediction")
async def read_prediction(): return FileResponse('static/prediction.html')

@app.get("/forgot-password")
async def read_forgot_password(): return FileResponse('static/forgot_password.html')

@app.get("/reset-password")
async def read_reset_password(): return FileResponse('static/reset_password.html')


# ==========================================
#      SECTION 3: WEATHER & FORECAST
# ==========================================

@app.get("/weather")
def get_weather():
    try:
        # Defaulting to Kotagiri for this project
        url = f"https://api.openweathermap.org/data/2.5/weather?q=Kotagiri,IN&appid={WEATHER_API_KEY}&units=metric"
        response = requests.get(url)
        data = response.json()
        if response.status_code != 200: raise HTTPException(status_code=500)
        
        frontend_data = {
            "location": data["name"],
            "temperature_celsius": round(data["main"]["temp"], 1),
            "condition": data["weather"][0]["description"].title(),
            "rain_probability": data.get("clouds", {}).get("all", 0),
            "humidity_percent": data["main"]["humidity"],
            "wind_kph": round(data["wind"]["speed"] * 3.6, 1),
            "day": datetime.now().strftime("%A"),
            "date": datetime.now().strftime("%d %B %Y")
        }
        
        # Log weather snapshot to DB for future ML training
        try:
            supabase.table("weather_log").insert({
                "location": frontend_data["location"],
                "temperature_celsius": frontend_data["temperature_celsius"],
                "condition": frontend_data["condition"],
                "rain_probability": frontend_data["rain_probability"],
                "humidity_percent": frontend_data["humidity_percent"],
                "wind_kph": frontend_data["wind_kph"]
            }).execute()
        except Exception as db_err:
            print(f"âš ï¸ Weather DB Log failed: {db_err}")
            
        return frontend_data
    except Exception as e: 
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/forecast")
def get_forecast():
    try:
        # Coordinates for Kotagiri
        lat, lon = 11.42, 76.87
        url = f"https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}&units=metric&appid={WEATHER_API_KEY}"
        
        response = requests.get(url)
        data = response.json()

        if response.status_code != 200:
            raise HTTPException(status_code=response.status_code, detail=data)

        # --- 1. Process & INTERPOLATE Hourly Data (Smoother Graphs) ---
        raw_list = data["list"][:17] # Get enough points to cover 48 hours
        hourly_interpolated = []

        for i in range(len(raw_list) - 1):
            start = raw_list[i]
            end = raw_list[i+1]

            # Create 3 hourly points between the 3-hour gaps provided by API
            for hour_offset in range(3):
                factor = hour_offset / 3.0
                
                t_start = datetime.utcfromtimestamp(start["dt"])
                t_current = t_start + timedelta(hours=hour_offset)
                
                # Linear interpolation for smooth data
                temp = start["main"]["temp"] + (end["main"]["temp"] - start["main"]["temp"]) * factor
                pop = start.get("pop", 0) + (end.get("pop", 0) - start.get("pop", 0)) * factor
                wind = start["wind"]["speed"] + (end["wind"]["speed"] - start["wind"]["speed"]) * factor

                # Rain Volume approximation
                rain_vol_start = start.get("rain", {}).get("3h", 0) / 3.0
                rain_vol_end = end.get("rain", {}).get("3h", 0) / 3.0
                rain_vol = rain_vol_start + (rain_vol_end - rain_vol_start) * factor

                hourly_interpolated.append({
                    "time": t_current.strftime("%I %p").lstrip('0').lower(), 
                    "day": t_current.strftime("%a"),
                    "temp": round(temp, 1),
                    "rain_prob": int(pop * 100),
                    "rain_mm": round(rain_vol, 2),
                    "wind": round(wind, 1),
                    "condition": start["weather"][0]["description"].replace(" ", "\n"),
                    "icon": start["weather"][0]["icon"]
                })
                
                if len(hourly_interpolated) >= 48:
                    break
            if len(hourly_interpolated) >= 48:
                break

        # --- 2. Daily Aggregation ---
        daily_agg = defaultdict(lambda: {
            "temps": [], "humidities": [], "pressures": [], "winds": [], "rain_sum": 0,
            "weather_ids": [], "icon": None, "desc": None, "day_name": None, "date_full": None,
            "parts": {"morn": [], "after": [], "eve": [], "night": []}
        })
        
        # Get dynamic sunrise/sunset
        sunrise = datetime.utcfromtimestamp(data["city"]["sunrise"]).strftime("%H:%M")
        sunset = datetime.utcfromtimestamp(data["city"]["sunset"]).strftime("%H:%M")

        for entry in data["list"]:
            date_obj = datetime.utcfromtimestamp(entry["dt"])
            date_str = date_obj.strftime("%Y-%m-%d")
            hour = date_obj.hour
            
            if not daily_agg[date_str]["day_name"]:
                daily_agg[date_str]["day_name"] = date_obj.strftime("%a, %b %d")
                daily_agg[date_str]["date_full"] = date_str
            
            daily_agg[date_str]["temps"].append(entry["main"]["temp"])
            daily_agg[date_str]["humidities"].append(entry["main"]["humidity"])
            daily_agg[date_str]["pressures"].append(entry["main"]["pressure"])
            daily_agg[date_str]["winds"].append(entry["wind"]["speed"])
            if "rain" in entry and "3h" in entry["rain"]:
                daily_agg[date_str]["rain_sum"] += entry["rain"]["3h"]
            
            # Pick the weather icon from the middle of the day (noon)
            if hour >= 12 and daily_agg[date_str]["icon"] is None:
                daily_agg[date_str]["icon"] = entry["weather"][0]["icon"]
                daily_agg[date_str]["desc"] = entry["weather"][0]["description"].title()

            # Bucketing for Morning/Afternoon/Evening/Night
            if 6 <= hour < 12: daily_agg[date_str]["parts"]["morn"].append(entry["main"]["temp"])
            elif 12 <= hour < 17: daily_agg[date_str]["parts"]["after"].append(entry["main"]["temp"])
            elif 17 <= hour < 21: daily_agg[date_str]["parts"]["eve"].append(entry["main"]["temp"])
            else: daily_agg[date_str]["parts"]["night"].append(entry["main"]["temp"])

        daily_forecast = []
        for date_key, val in daily_agg.items():
            def avg(lst): return round(sum(lst)/len(lst), 1) if lst else "N/A"
            if not val["icon"]: val["icon"] = "02d"; val["desc"] = "Cloudy"

            daily_forecast.append({
                "date": val["day_name"], 
                "temp_max": round(max(val["temps"])),
                "temp_min": round(min(val["temps"])),
                "rain_total": round(val["rain_sum"], 1),
                "humidity": round(sum(val["humidities"]) / len(val["humidities"])),
                "wind": round(sum(val["winds"]) / len(val["winds"]), 1),
                "pressure": round(sum(val["pressures"]) / len(val["pressures"])),
                "icon": val["icon"],
                "description": val["desc"],
                "sunrise": sunrise,
                "sunset": sunset,
                "morn": avg(val["parts"]["morn"]),
                "after": avg(val["parts"]["after"]),
                "eve": avg(val["parts"]["eve"]),
                "night": avg(val["parts"]["night"])
            })

        return {
            "daily": daily_forecast,
            "hourly": hourly_interpolated 
        }

    except Exception as e:
        print("âŒ FORECAST ERROR:", e)
        raise HTTPException(status_code=500, detail=str(e))